from collections import deque

# Goal state
GOAL = ((1, 2, 3),
        (4, 5, 6),
        (7, 8, 0))

# Directions: up, down, left, right
DIRS = [(-1, 0), (1, 0), (0, -1), (0, 1)]

def find_zero(state):
    """Find the position (row, col) of the empty tile (0)."""
    for r in range(3):
        for c in range(3):
            if state[r][c] == 0:
                return r, c

def swap(state, r1, c1, r2, c2):
    """Swap two tiles in the puzzle state and return new state."""
    state_list = [list(row) for row in state]
    state_list[r1][c1], state_list[r2][c2] = state_list[r2][c2], state_list[r1][c1]
    return tuple(tuple(row) for row in state_list)

def get_neighbors(state):
    """Generate all valid neighbors by sliding the empty tile."""
    neighbors = []
    r, c = find_zero(state)
    for dr, dc in DIRS:
        nr, nc = r + dr, c + dc
        if 0 <= nr < 3 and 0 <= nc < 3:
            new_state = swap(state, r, c, nr, nc)
            neighbors.append(new_state)
    return neighbors

def dfs(start):
    stack = [(start, [])]  # stack stores (state, path)
    visited = set()

    while stack:
        state, path = stack.pop()

        if state == GOAL:
            return path + [state]

        if state in visited:
            continue
        visited.add(state)

        for neighbor in get_neighbors(state):
            if neighbor not in visited:
                stack.append((neighbor, path + [state]))

    return None  # No solution found

def print_state(state):
    for row in state:
        print(' '.join(str(x) if x != 0 else ' ' for x in row))
    print()

if __name__ == "__main__":
    # Example start state (can change to any solvable configuration)
    start_state = ((1, 2, 3),
                   (4, 0, 6),
                   (7, 5, 8))

    solution = dfs(start_state)

    if solution:
        print(f"Solution found in {len(solution) - 1} moves:")
        for step in solution:
            print_state(step)
    else:
        print("No solution found.")
